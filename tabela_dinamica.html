<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerenciamento Dinâmico de Tabelas</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; position: relative; }
        table, th, td { border: 1px solid black; border-collapse: collapse; padding: 8px; }
        th { background-color: #f2f2f2; cursor: pointer; }
        button { padding: 5px 10px; margin: 5px; }
        #dynamicForm { margin-bottom: 20px; padding: 10px; border: 1px solid #ccc; display: none; }
        #dynamicForm label { display: block; margin: 5px 0; }
        #errorMessage { color: red; margin: 10px 0; }
        #successMessage { color: green; margin: 10px 0; }
        #loadingMessage { color: blue; }
        #tableSelection { position: absolute; top: 20px; right: 20px; }
        #tableUtilities { margin-top: 10px; display: none; }
        #columnSelection { 
            margin-top: 10px; 
            display: none; 
            padding: 10px; 
            border: 1px solid black; 
            background-color: white;
        }
        #columnSelection label { display: block; margin: 5px 0; }
        #tableContainer { margin-top: 80px; }
        #pkSelection { margin: 10px 0; display: none; }
        #paginationControls { margin-top: 10px; text-align: center; }
        .pagination-btn { padding: 5px 10px; margin: 0 2px; }
        .edit-row input { width: 95%; }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            text-align: center;
            border-radius: 5px;
        }
        .modal-buttons {
            margin-top: 20px;
        }
        .modal-buttons button {
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            border: none;
            border-radius: 3px;
        }
        #confirmDownloadModal .modal-buttons button:nth-child(1) {
            background-color: #4CAF50;
            color: white;
        }
        #confirmDownloadModal .modal-buttons button:nth-child(2) {
            background-color: #f44336;
            color: white;
        }
        #confirmDownloadModal .modal-buttons button:nth-child(3) {
            background-color: #ff9800;
            color: white;
        }
        #confirmNoDownloadModal .modal-buttons button:nth-child(1) {
            background-color: #f44336;
            color: white;
        }
        #confirmNoDownloadModal .modal-buttons button:nth-child(2) {
            background-color: #4CAF50;
            color: white;
        }
    </style>
</head>
<body>
    <h1>Gerenciamento Dinâmico de Tabelas</h1>
    <div id="tableSelection">
        <button id="selectTableButton">Selecionar Tabela</button>
        <button id="columnSelectionButton">Modo de Seleção</button>
        <div id="columnSelection"></div>
        <div id="tableUtilities">
            <input type="text" id="globalSearchInput" placeholder="Buscar em qualquer coluna..." />
            <button id="restoreViewButton">Restaurar</button>
            <button id="downloadLogButton" style="display: none;">Baixar Log de Exclusões</button>
        </div>
    </div>
    <div id="successMessage"></div>
    <div id="errorMessage"></div>
    <div id="loadingMessage">Carregando...</div>
    <div id="pkSelection">
        <label>Selecione a chave primária: 
            <select id="pkSelect"></select>
        </label>
        <button id="confirmPkButton-famous">Confirmar</button>
    </div>
    <div id="tableContainer" style="display: none;">
        <div id="dynamicForm">
            <form id="dynamicFormFields"></form>
            <button type="button" id="saveButton">Salvar</button>
            <button type="button" id="cancelButton">Cancelar</button>
        </div>
        <button id="addNewButton">Adicionar Novo Registro</button>
        <table id="dynamicTable">
            <thead id="dynamicTableHead"></thead>
            <tbody id="dynamicTableBody"></tbody>
        </table>
        <div id="paginationControls"></div>
    </div>
    <div id="confirmDownloadModal" class="modal">
        <div class="modal-content">
            <h2>Logs de Exclusões Pendentes</h2>
            <p>Você tem logs de exclusões pendentes. O que deseja fazer?</p>
            <div class="modal-buttons">
                <button id="downloadYes">BAIXAR (seguro)</button>
                <button id="downloadCancel">CANCELAR</button>
                <button id="downloadNo">NÃO BAIXAR</button>
            </div>
        </div>
    </div>
    <div id="confirmNoDownloadModal" class="modal">
        <div class="modal-content">
            <h2>Confirmação</h2>
            <p>Tem certeza que quer sair sem baixar o SecureLog?</p>
            <div class="modal-buttons">
                <button id="noDownloadYes">SIM, não salvar</button>
                <button id="noDownloadNo">NÃO, cancelar</button>
            </div>
        </div>
    </div>
    <script>
       const lix = [
            '',  
            ...'abcdefghijklmnopqrstuvwxyz',
            ...'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
            ...Array.from({length: 10}, (_, i) => i.toString()),
            '.', '-', '@', '!', '$', '%', '&', '#', '/', ':', '?', '_'
        ];

       function enco(input) {
            return input
                .split('')
                .map(char => {
                    const idx = lix.indexOf(char);
                    if (idx === -1) throw new Error(`Character "${char}" not found in list.`);
                    const strIdx = idx < 10 ? '0' + idx : idx.toString();
                    return strIdx;
                })
                .join('');
        }

       function deco(encodedStr) {
            if (encodedStr.length % 2 !== 0) {
                throw new Error('Encoded string has odd length.');
            }
            const chars = [];
            for (let i = 0; i < encodedStr.length; i += 2) {
                const index = parseInt(encodedStr.substring(i, i + 2), 10);
                if (index < 1 || index >= lix.length) throw new Error(`Invalid index "${index}" in encoded string.`);
                chars.push(lix[index]);
            }
            return chars.join('');
        }

        const supabaseUrl = 'https://eygsxxhjxeugfhaysfjm.supabase.co';
        const supabaseKey = '05253608023303094109363547263554400935193514445803293559351116504829366263052536160356390941093626045028085113322652453519351436125209355935134858525640570533081705334854525552155150122652131620350923090313621952453559351332210255570938293616515043094110315640304356403047584030471935134857032935593910275539303925394611534050536319620722205403221559065120324022105515606064463312444555183524592615266456545303280831';
        const sbasey = deco(supabaseKey).trim();
        const supabase = window.supabase.createClient(supabaseUrl, sbasey);

        let currentTable = null;
        let columns = [];
        let originalColumnOrder = [];
        let visibleColumns = [];
        let primaryKey = null;
        let isPkInteger = false;
        let lastPkValue = 0;
        let originalPkValue = null;
        let allData = [];
        let filteredData = [];
        let currentPage = 1;
        const rowsPerPage = 20;
        let currentSort = { column: null, order: 'asc' };
        let initialSort = { column: null, order: 'asc' };
        let subscriptionChannel = null;
        let isRealtimeConnected = false;
        let secureLog = null;
        let allowUnload = false;
        let isKeyboardAction = false;

        const confirmDownloadModal = document.getElementById('confirmDownloadModal');
        const confirmNoDownloadModal = document.getElementById('confirmNoDownloadModal');

        function getTimestamp() {
            return new Date().toISOString();
        }

        function updateSecureLog(record) {
            const timestamp = getTimestamp();
            if (secureLog === null) {
                secureLog = `SecureLog ${timestamp}\n`;
                document.getElementById('downloadLogButton').style.display = 'inline';
            }
            secureLog += `[${timestamp}] Dados excluídos: ${JSON.stringify(record)}\n`;
        }

        function downloadSecureLog() {
            if (secureLog === null) return;
            const blob = new Blob([secureLog], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sql_SecureLog.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        document.getElementById('downloadLogButton').onclick = () => {
            downloadSecureLog();
        };

        function openModal(modal) {
            modal.style.display = 'block';
        }

        function closeModal(modal) {
            modal.style.display = 'none';
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'F5' || (event.ctrlKey && event.key === 'r') || (event.metaKey && event.key === 'r')) {
                event.preventDefault();
                isKeyboardAction = true;
                if (secureLog !== null) {
                    openModal(confirmDownloadModal);
                } else {
                    window.location.reload();
                }
            }
        });

        window.addEventListener('beforeunload', (event) => {
            if (allowUnload) {
                allowUnload = false;
                return;
            }
            if (isKeyboardAction) {
                isKeyboardAction = false;
                return;
            }
            if (secureLog !== null) {
                event.preventDefault();
                event.returnValue = '';
                openModal(confirmDownloadModal);
            }
        });

        document.getElementById('downloadYes').onclick = () => {
            downloadSecureLog();
            allowUnload = true;
            closeModal(confirmDownloadModal);
            window.location.reload();
        };

        document.getElementById('downloadCancel').onclick = () => {
            closeModal(confirmDownloadModal);
            isKeyboardAction = false;
        };

        document.getElementById('downloadNo').onclick = () => {
            closeModal(confirmDownloadModal);
            openModal(confirmNoDownloadModal);
        };

        document.getElementById('noDownloadYes').onclick = () => {
            allowUnload = true;
            closeModal(confirmNoDownloadModal);
            window.location.reload();
        };

        document.getElementById('noDownloadNo').onclick = () => {
            closeModal(confirmNoDownloadModal);
            isKeyboardAction = false;
        };

        function clearMessages() {
            document.getElementById('successMessage').textContent = '';
            document.getElementById('errorMessage').textContent = '';
        }

        function checkRealtimeConnection() {
            if (isRealtimeConnected) {
                document.getElementById('successMessage').textContent = 'Conectado em tempo real!';
                document.getElementById('errorMessage').textContent = '';
            } else {
                document.getElementById('successMessage').textContent = '';
                document.getElementById('errorMessage').textContent = 'Desconectado do tempo real. Tentando reconectar...';
            }
        }

        setInterval(checkRealtimeConnection, 10000);

        document.getElementById('selectTableButton').onclick = async () => {
            clearMessages();
            const tableName = prompt('Digite o nome da tabela (exemplo: alunos, ongs):');
            if (!tableName) {
                document.getElementById('errorMessage').textContent = 'Nome da tabela não pode ser vazio.';
                return;
            }
            currentTable = tableName;
            const { data, error } = await supabase.from(tableName).select('*').limit(1);
            if (error) {
                document.getElementById('errorMessage').textContent = `Erro ao acessar a tabela: ${error.message}`;
                return;
            }
            if (!data || !data.length) {
                document.getElementById('errorMessage').textContent = 'Tabela vazia. Adicione um registro para começar.';
                return;
            }
            columns = Object.keys(data[0]);
            originalColumnOrder = [...columns];
            visibleColumns = [...columns];
            populatePkSelector(columns);
            populateColumnSelection();
            document.getElementById('pkSelection').style.display = 'block';
        };

        function populatePkSelector(columns) {
            const select = document.getElementById('pkSelect');
            select.innerHTML = '';
            columns.forEach(c => {
                const option = document.createElement('option');
                option.value = c;
                option.textContent = c;
                select.appendChild(option);
            });
        }

        function populateColumnSelection() {
            const container = document.getElementById('columnSelection');
            container.innerHTML = '<h4>Selecione as colunas a visualizar:</h4>';
            originalColumnOrder.forEach(col => {
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = visibleColumns.includes(col);
                checkbox.onchange = () => {
                    if (checkbox.checked) {
                        const newVisibleColumns = originalColumnOrder.filter(c => 
                            visibleColumns.includes(c) || c === col
                        );
                        visibleColumns = newVisibleColumns;
                    } else {
                        visibleColumns = visibleColumns.filter(c => c !== col);
                    }
                    generateTableHeader();
                    renderTablePage();
                };
                label.appendChild(checkbox);
                label.append(` ${col}`);
                container.appendChild(label);
            });
        }

        document.getElementById('columnSelectionButton').onclick = () => {
            if (!currentTable) {
                document.getElementById('errorMessage').textContent = 'Selecione uma tabela primeiro.';
                return;
            }
            const container = document.getElementById('columnSelection');
            container.style.display = container.style.display === 'block' ? 'none' : 'block';
        };

        document.getElementById('confirmPkButton-famous').onclick = async () => {
            primaryKey = document.getElementById('pkSelect').value;
            if (!primaryKey) {
                document.getElementById('errorMessage').textContent = 'Selecione uma chave primária.';
                return;
            }
            await loadTable();
        };

        async function checkForDuplicatePk(pkValue, excludeOriginal = null) {
            try {
                let query = supabase.from(currentTable).select(primaryKey).eq(primaryKey, pkValue);
                if (excludeOriginal !== null) {
                    query = query.neq(primaryKey, excludeOriginal);
                }
                const { data, error } = await query;
                if (error) throw error;
                return data.length > 0;
            } catch (error) {
                document.getElementById('errorMessage').textContent = `Erro ao verificar duplicatas: ${error.message}`;
                return true;
            }
        }

        async function loadTable() {
            clearMessages();
            document.getElementById('pkSelection').style.display = 'none';
            document.getElementById('tableContainer').style.display = 'block';
            document.getElementById('tableUtilities').style.display = 'block';
            document.getElementById('loadingMessage').style.display = 'block';

            if (subscriptionChannel) {
                supabase.removeChannel(subscriptionChannel);
                isRealtimeConnected = false;
            }

            try {
                const { data, error } = await supabase.from(currentTable).select('*');
                if (error) {
                    document.getElementById('errorMessage').textContent = `Erro ao carregar dados: ${error.message}`;
                    return;
                }
                allData = data;
                filteredData = [...data];
                const pkValues = data.map(r => r[primaryKey]);
                isPkInteger = pkValues.every(v => Number.isInteger(Number(v)));
                lastPkValue = isPkInteger ? Math.max(...pkValues.map(Number).filter(v => !isNaN(v))) : 0;

                if (isPkInteger) {
                    currentSort = { column: primaryKey, order: 'desc' };
                } else {
                    currentSort = { column: primaryKey, order: 'asc' };
                }
                initialSort = { ...currentSort };

                generateTableHeader();
                sortAndRender();

                subscriptionChannel = supabase.channel(`${currentTable}-channel`)
                    .on('postgres_changes', { event: '*', schema: 'public', table: currentTable }, payload => {
                        console.log('Mudança detectada:', payload);
                        loadTable();
                    })
                    .subscribe(status => {
                        if (status === 'SUBSCRIBED') {
                            isRealtimeConnected = true;
                            checkRealtimeConnection();
                        } else {
                            isRealtimeConnected = false;
                            checkRealtimeConnection();
                        }
                    });
            } catch (error) {
                document.getElementById('errorMessage').textContent = `Erro ao carregar tabela: ${error.message}`;
            } finally {
                document.getElementById('loadingMessage').style.display = 'none';
            }
        }

        function generateTableHeader() {
            const thead = document.getElementById('dynamicTableHead');
            thead.innerHTML = '';
            const tr = document.createElement('tr');
            visibleColumns.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col;
                th.onclick = () => {
                    currentSort = {
                        column: col,
                        order: currentSort.column === col && currentSort.order === 'asc' ? 'desc' : 'asc'
                    };
                    sortAndRender();
                };
                tr.appendChild(th);
            });
            const thAction = document.createElement('th');
            thAction.textContent = 'Ações';
            tr.appendChild(thAction);
            thead.appendChild(tr);
        }

        function sortAndRender() {
            const { column, order } = currentSort;
            if (!visibleColumns.includes(column) && currentSort !== initialSort) {
                currentSort.column = primaryKey;
                currentSort.order = isPkInteger ? 'desc' : 'asc';
            }
            filteredData.sort((a, b) => {
                let valA = a[currentSort.column], valB = b[currentSort.column];
                valA = valA !== null ? valA.toString().toLowerCase() : '';
                valB = valB !== null ? valB.toString().toLowerCase() : '';
                if (!isNaN(valA) && !isNaN(valB)) {
                    valA = Number(valA);
                    valB = Number(valB);
                }
                return (valA > valB ? 1 : valA < valB ? -1 : 0) * (order === 'asc' ? 1 : -1);
            });
            renderTablePage();
        }

        function renderTablePage() {
            const start = (currentPage - 1) * rowsPerPage;
            const end = start + rowsPerPage;
            const pageData = filteredData.slice(start, end);
            const tbody = document.getElementById('dynamicTableBody');
            tbody.innerHTML = '';
            pageData.forEach(record => {
                const tr = document.createElement('tr');
                visibleColumns.forEach(col => {
                    const td = document.createElement('td');
                    td.textContent = record[col] ?? '';
                    tr.appendChild(td);
                });
                const actionTd = document.createElement('td');
                actionTd.innerHTML = `
                    <button onclick="editInline('${record[primaryKey]}')">Editar</button>
                    <button onclick="deleteRecord('${record[primaryKey]}')">Excluir</button>
                `;
                tr.appendChild(actionTd);
                tbody.appendChild(tr);
            });
            renderPaginationControls();
        }

        function renderPaginationControls() {
            const total = filteredData.length;
            const totalPages = Math.ceil(total / rowsPerPage);
            const container = document.getElementById('paginationControls');
            container.innerHTML = '';
            for (let i = 1; i <= totalPages; i++) {
                const btn = document.createElement('button');
                btn.textContent = i;
                btn.className = 'pagination-btn';
                btn.disabled = i === currentPage;
                btn.onclick = () => { currentPage = i; renderTablePage(); };
                container.appendChild(btn);
            }
        }

        document.getElementById('globalSearchInput').oninput = (e) => {
            const val = e.target.value.toLowerCase();
            filteredData = allData.filter(row =>
                Object.values(row).some(v => v?.toString().toLowerCase().includes(val))
            );
            currentPage = 1;
            sortAndRender();
        };

        document.getElementById('restoreViewButton').onclick = () => {
            filteredData = [...allData];
            visibleColumns = [...originalColumnOrder];
            currentSort = { ...initialSort };
            document.getElementById('columnSelection').innerHTML = '';
            populateColumnSelection();
            generateTableHeader();
            sortAndRender();
            currentPage = 1;
        };

        document.getElementById('addNewButton').onclick = () => {
            clearMessages();
            document.getElementById('dynamicFormFields').innerHTML = '';
            columns.forEach(col => {
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `field_${col}`;
                input.value = col === primaryKey && isPkInteger ? lastPkValue + 1 : '';
                const label = document.createElement('label');
                label.textContent = `${col}: `;
                label.appendChild(input);
                document.getElementById('dynamicFormFields').appendChild(label);
            });
            originalPkValue = null;
            document.getElementById('dynamicForm').style.display = 'block';
        };

        document.getElementById('saveButton').onclick = async () => {
            clearMessages();
            const record = {};
            columns.forEach(col => record[col] = document.getElementById(`field_${col}`).value || null);

            const isUpdate = originalPkValue !== null;

            const pkValue = record[primaryKey];
            const hasDuplicate = await checkForDuplicatePk(pkValue, isUpdate ? originalPkValue : null);
            if (hasDuplicate) {
                document.getElementById('errorMessage').textContent = `Erro: O valor "${pkValue}" para a chave primária já existe na tabela. Escolha outro valor.`;
                return;
            }

            try {
                if (isUpdate) {
                    const { error: deleteError } = await supabase.from(currentTable).delete().eq(primaryKey, originalPkValue);
                    if (deleteError) throw deleteError;
                    const { error: insertError } = await supabase.from(currentTable).insert([record]);
                    if (insertError) throw insertError;
                } else {
                    const { error } = await supabase.from(currentTable).insert([record]);
                    if (error) throw error;
                }
                document.getElementById('dynamicForm').style.display = 'none';
                originalPkValue = null;
                await loadTable();
            } catch (error) {
                document.getElementById('errorMessage').textContent = `Erro ao salvar registro: ${error.message}`;
            }
        };

        document.getElementById('cancelButton').onclick = () => {
            clearMessages();
            document.getElementById('dynamicForm').style.display = 'none';
            originalPkValue = null;
        };

        // Prepara a edição inline de um registro
        async function editInline(id) {
            clearMessages();
            try {
                const { data, error } = await supabase.from(currentTable).select('*').eq(primaryKey, id);
                if (error || !data || !data.length) {
                    document.getElementById('errorMessage').textContent = `Erro ao buscar registro para edição: ${error?.message || 'Registro não encontrado'}`;
                    return;
                }
                const rowIndex = filteredData.findIndex(r => r[primaryKey] == id);
                const row = document.querySelector(`#dynamicTableBody tr:nth-child(${rowIndex + 1})`);
                row.innerHTML = '';
                visibleColumns.forEach(col => {
                    const td = document.createElement('td');
                    td.innerHTML = `<input type="text" id="edit_${col}" value="${data[0][col] ?? ''}" />`;
                    row.appendChild(td);
                });
                const tdActions = document.createElement('td');
                tdActions.innerHTML = `<button onclick="confirmEdit('${id}')">Salvar</button><button onclick="loadTable()">Cancelar</button>`;
                row.appendChild(tdActions);
                originalPkValue = id;
            } catch (error) {
                document.getElementById('errorMessage').textContent = `Erro ao preparar edição: ${error.message}`;
            }
        }

        // Confirma a edição inline
        async function confirmEdit(id) {
            clearMessages();
            const updated = {};
            columns.forEach(col => {
                const input = document.getElementById(`edit_${col}`);
                updated[col] = input ? input.value || null : allData.find(r => r[primaryKey] == id)[col];
            });

            const pkValue = updated[primaryKey];
            const hasDuplicate = await checkForDuplicatePk(pkValue, id);
            if (hasDuplicate) {
                document.getElementById('errorMessage').textContent = `Erro: O valor "${pkValue}" para a chave primária já existe na tabela. Escolha outro valor.`;
                return;
            }

            try {
                const { error: deleteError } = await supabase.from(currentTable).delete().eq(primaryKey, id);
                if (deleteError) throw deleteError;
                const { error: insertError } = await supabase.from(currentTable).insert([updated]);
                if (insertError) throw insertError;
                originalPkValue = null;
                await loadTable();
            } catch (error) {
                document.getElementById('errorMessage').textContent = `Erro ao salvar edição: ${error.message}`;
            }
        }

        // Exclui um registro
        async function deleteRecord(id) {
            clearMessages();
            if (!confirm(`Deseja excluir o registro ${id}?`)) return;
            try {
                const { data, error: fetchError } = await supabase.from(currentTable).select('*').eq(primaryKey, id);
                if (fetchError || !data || !data.length) {
                    document.getElementById('errorMessage').textContent = `Erro ao buscar registro para exclusão: ${fetchError?.message || 'Registro não encontrado'}`;
                    return;
                }
                updateSecureLog(data[0]);
                const { error } = await supabase.from(currentTable).delete().eq(primaryKey, id);
                if (error) throw error;
                await loadTable();
            } catch (error) {
                document.getElementById('errorMessage').textContent = `Erro ao excluir registro: ${error.message}`;
            }
        }

        document.getElementById('loadingMessage').style.display = 'none';
    </script>
</body>
</html>
